**<p align="center">My 60 day LeetCode challenge**</p>

---

#### **День 1: [Two Sum](https://leetcode.com/problems/two-sum/) (Easy)**
- **Формулировка:** Дан массив целых чисел `nums` и целое число `target`. Найдите индексы двух чисел, которые в сумме дают `target`.
- **Пример:**
  - Вход: `nums = [2, 7, 11, 15]`, `target = 9`
  - Выход: `[0, 1]` (потому что `nums[0] + nums[1] = 2 + 7 = 9`)

- **Идея решения:** >! Используйте хэш-таблицу для хранения чисел и их индексов. Проходите по массиву и проверяйте, есть ли в таблице число `target - nums[i]`.

---

#### **День 2: [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) (Easy)**
- **Формулировка:** Дан массив цен на акции. Найдите максимальную прибыль, которую можно получить, купив акцию в один день и продав в другой.
- **Пример:**
  - Вход: `prices = [7, 1, 5, 3, 6, 4]`
  - Выход: `5` (купить за 1, продать за 6)
- **Идея решения:** Используйте два указателя: один для минимальной цены, другой для максимальной прибыли.
  
---

#### **День 3: [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) (Easy)**
- **Формулировка:** Дан массив целых чисел. Определите, содержит ли массив дубликаты.
- **Пример:**
  - Вход: `nums = [1, 2, 3, 1]`
  - Выход: `true`
- **Идея решения:** Используйте хэш-таблицу для проверки наличия дубликатов.
  
---

#### **День 4: [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) (Easy)**
- **Формулировка:** Дана строка. Определите, является ли она палиндромом, игнорируя небуквенные символы и регистр.
- **Пример:**
  - Вход: `s = "A man, a plan, a canal: Panama"`
  - Выход: `true`
- **Идея решения:** Используйте два указателя: один с начала строки, другой с конца.
  
---

#### **День 5: [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) (Easy)**
- **Формулировка:** Дан массив целых чисел. Найдите подмассив с максимальной суммой.
- **Пример:**
  - Вход: `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`
  - Выход: `6` (подмассив `[4, -1, 2, 1]`)
- **Идея решения:** Используйте алгоритм Кадане (Kadane's Algorithm).
  
---

#### **День 6: [Reverse String](https://leetcode.com/problems/reverse-string/) (Easy)**
- **Формулировка:** Дана строка. Переверните её на месте.
- **Пример:**
  - Вход: `s = ["h", "e", "l", "l", "o"]`
  - Выход: `["o", "l", "l", "e", "h"]`
- **Идея решения:** Используйте два указателя: один с начала, другой с конца.
  
---

#### **День 7: [3Sum](https://leetcode.com/problems/3sum/) (Medium)**
- **Формулировка:** Дан массив целых чисел. Найдите все уникальные тройки чисел, которые в сумме дают 0.
- **Пример:**
  - Вход: `nums = [-1, 0, 1, 2, -1, -4]`
  - Выход: `[[-1, -1, 2], [-1, 0, 1]]`
- **Идея решения:** Отсортируйте массив и используйте два указателя для поиска троек.
  
---

#### **День 8: [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) (Medium)**
- **Формулировка:** Дан массив высот. Найдите два столбца, которые образуют контейнер с наибольшим объемом воды.
- **Пример:**
  - Вход: `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`
  - Выход: `49`
- **Идея решения:** Используйте два указателя: один с начала, другой с конца.
  
---

#### **День 9: [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) (Medium)**
- **Формулировка:** Дана строка. Найдите длину самой длинной подстроки без повторяющихся символов.
- **Пример:**
  - Вход: `s = "abcabcbb"`
  - Выход: `3` ("abc")
- **Идея решения:** Используйте sliding window и хэш-таблицу.
  
---

#### **День 10: [Group Anagrams](https://leetcode.com/problems/group-anagrams/) (Medium)**
- **Формулировка:** Дан массив строк. Сгруппируйте анаграммы вместе.
- **Пример:**
  - Вход: `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`
  - Выход: `[["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]`
- **Идея решения:** Используйте хэш-таблицу, где ключ — отсортированная строка.
  
---

#### **День 11: [Sort Colors](https://leetcode.com/problems/sort-colors/) (Medium)**
- **Формулировка:** Дан массив, содержащий числа 0, 1 и 2. Отсортируйте его на месте.
- **Пример:**
  - Вход: `nums = [2, 0, 2, 1, 1, 0]`
  - Выход: `[0, 0, 1, 1, 2, 2]`
- **Идея решения:** Используйте три указателя (Dutch National Flag Algorithm).
  
---

#### **День 12: [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) (Medium)**
- **Формулировка:** Дан массив целых чисел. Верните массив, где каждый элемент равен произведению всех элементов исходного массива, кроме текущего.
- **Пример:**
  - Вход: `nums = [1, 2, 3, 4]`
  - Выход: `[24, 12, 8, 6]`
- **Идея решения:** Используйте префиксные и суффиксные произведения.
  
---

#### **День 13: [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) (Medium)**
- **Формулировка:** Даны две строки `s` и `p`. Найдите все начальные индексы подстрок в `s`, которые являются анаграммами `p`.
- **Пример:**
  - Вход: `s = "cbaebabacd"`, `p = "abc"`
  - Выход: `[0, 6]`
- **Идея решения:** Используйте sliding window и хэш-таблицу для подсчета символов.

---

#### **День 14: [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) (Hard)**
- **Формулировка:** Дан массив высот. Найдите, сколько воды может быть захвачено между столбцами.
- **Пример:**
  - Вход: `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`
  - Выход: `6`
- **Идея решения:** Используйте два указателя или динамическое программирование.
  
---

#### **День 15: [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) (Easy)**
- **Формулировка:** Разверните односвязный список.
- **Пример:**
  - Вход: `1 -> 2 -> 3 -> 4 -> 5`
  - Выход: `5 -> 4 -> 3 -> 2 -> 1`
- **Идея решения:** Используйте три указателя: предыдущий, текущий и следующий.
  
---

#### **День 16: [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) (Easy)**
- **Формулировка:** Объедините два отсортированных связных списка в один.
- **Пример:**
  - Вход: `1 -> 2 -> 4`, `1 -> 3 -> 4`
  - Выход: `1 -> 1 -> 2 -> 3 -> 4 -> 4`
- **Идея решения:** Используйте два указателя для объединения списков.
  
---

#### **День 17: [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) (Easy)**
- **Формулировка:** Определите, содержит ли связный список цикл.
- **Пример:**
  - Вход: `1 -> 2 -> 3 -> 4 -> 2` (цикл)
  - Выход: `true`
- **Идея решения:** Используйте алгоритм "черепахи и зайца" (Floyd's Cycle Detection).
  
---

#### **День 18: [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) (Medium)**
- **Описание:** Даны два непустых односвязных списка, представляющих два числа. Нужно вернуть список, представляющий их сумму.
- **Пример:**
  - Вход: `2 -> 4 -> 3`, `5 -> 6 -> 4`
  - Выход: `7 -> 0 -> 8` (342 + 465 = 807)
- **Ключевые моменты:**
  - Используйте сложение с переносом.
    
---

#### **День 19: [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) (Medium)**
- **Описание:** Дан односвязный список и число `n`. Нужно удалить `n`-й элемент с конца списка.
- **Пример:**
  - Вход: `1 -> 2 -> 3 -> 4 -> 5`, `n = 2`
  - Выход: `1 -> 2 -> 3 -> 5`
- **Ключевые моменты:**
  - Используйте два указателя: один на `n` шагов впереди.
    
---

#### **День 20: [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) (Hard)**
- **Описание:** Дан массив из `k` отсортированных односвязных списков. Нужно объединить их в один отсортированный список.
- **Пример:**
  - Вход: `[1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6]`
  - Выход: `1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6`
- **Ключевые моменты:**
  - Используйте минимальную кучу (min-heap).
    
---

#### **День 21: [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) (Hard)**
- **Описание:** Даны два отсортированных массива. Нужно найти медиану объединенного массива.
- **Пример:**
  - Вход: `nums1 = [1, 3]`, `nums2 = [2]`
  - Выход: `2.0`
- **Ключевые моменты:**
  - Используйте бинарный поиск для эффективного решения.
    
---

#### **День 22: [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) (Easy)**
- **Формулировка:** Найдите максимальную глубину бинарного дерева.
- **Пример:**
  - Вход: Дерево `[3, 9, 20, null, null, 15, 7]`
  - Выход: `3`
- **Идея решения:** Используйте рекурсию для обхода дерева.
  
---

#### **День 23: [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) (Easy)**
- **Формулировка:** Определите, является ли бинарное дерево симметричным.
- **Пример:**
  - Вход: Дерево `[1, 2, 2, 3, 4, 4, 3]`
  - Выход: `true`
- **Идея решения:** Используйте рекурсию для сравнения левого и правого поддеревьев.

---

#### **День 24: [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) (Medium)**
- **Описание:** Дано бинарное дерево. Нужно проверить, является ли оно валидным бинарным деревом поиска.
- **Пример:**
  - Вход: Дерево `[2, 1, 3]`
  - Выход: `true`
- **Ключевые моменты:**
  - Используйте рекурсию с передачей минимального и максимального значений.

---

#### **День 25: [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) (Medium)**
- **Описание:** Дано бинарное дерево. Нужно вернуть список уровней дерева.
- **Пример:**
  - Вход: Дерево `[3, 9, 20, null, null, 15, 7]`
  - Выход: `[[3], [9, 20], [15, 7]]`
- **Ключевые моменты:**
  - Используйте обход в ширину (BFS) с очередью.

---

#### **День 26: [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) (Medium)**
- **Описание:** Даны два массива: префиксный (preorder) и инфиксный (inorder) обходы бинарного дерева. Нужно восстановить дерево.
- **Пример:**
  - Вход: `preorder = [3, 9, 20, 15, 7]`, `inorder = [9, 3, 15, 20, 7]`
  - Выход: Дерево `[3, 9, 20, null, null, 15, 7]`
- **Ключевые моменты:**
  - Используйте рекурсию и хэш-таблицу для индексов.

---

#### **День 27: [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) (Medium)**
- **Описание:** Дано бинарное дерево. Нужно преобразовать его в односвязный список.
- **Пример:**
  - Вход: Дерево `[1, 2, 5, 3, 4, null, 6]`
  - Выход: `1 -> 2 -> 3 -> 4 -> 5 -> 6`
- **Ключевые моменты:**
  - Используйте модифицированный обход в глубину (DFS).

---

#### **День 28: [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) (Hard)**
- **Описание:** Нужно реализовать функции для сериализации и десериализации бинарного дерева.
- **Пример:**
  - Вход: Дерево `[1, 2, 3, null, null, 4, 5]`
  - Выход: Сериализованная строка, например, `"1,2,null,null,3,4,null,null,5,null,null"`
- **Ключевые моменты:**
  - Используйте обход в глубину (DFS) для сериализации и десериализации.


---

#### **День 29: [Number of Islands](https://leetcode.com/problems/number-of-islands/) (Medium)**
- **Формулировка:** Дан двумерный массив. Найдите количество "островов" (групп `1`, окруженных `0`).
- **Пример:**
  - Вход: 
    ```
    [
      ["1", "1", "0", "0", "0"],
      ["1", "1", "0", "0", "0"],
      ["0", "0", "1", "0", "0"],
      ["0", "0", "0", "1", "1"]
    ]
    ```
  - Выход: `3`
- **Идея решения:** Используйте DFS или BFS для обхода островов.

---

#### **День 30: [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) (Easy)**
- **Формулировка:** Вы поднимаетесь по лестнице. За один шаг можно подняться на 1 или 2 ступеньки. Сколько существует способов подняться на `n` ступенек?
- **Пример:**
  - Вход: `n = 3`
  - Выход: `3` (1+1+1, 1+2, 2+1)
- **Идея решения:** Используйте динамическое программирование (DP) или числа Фибоначчи.

---

#### **День 31: [House Robber](https://leetcode.com/problems/house-robber/) (Medium)**
- **Формулировка:** Дан массив, где каждый элемент представляет сумму денег в доме. Вор не может грабить два соседних дома. Найдите максимальную сумму, которую можно украсть.
- **Пример:**
  - Вход: `nums = [2, 7, 9, 3, 1]`
  - Выход: `12` (2 + 9 + 1)
- **Идея решения:** Используйте динамическое программирование для выбора оптимального пути.

---

#### **День 32: [Word Break](https://leetcode.com/problems/word-break/) (Medium)**
- **Формулировка:** Дана строка `s` и список слов `wordDict`. Определите, можно ли разбить строку на слова из списка.
- **Пример:**
  - Вход: `s = "leetcode"`, `wordDict = ["leet", "code"]`
  - Выход: `true`
- **Идея решения:** Используйте динамическое программирование для проверки всех возможных разбиений.

---

#### **День 33: [Combination Sum](https://leetcode.com/problems/combination-sum/) (Medium)**
- **Формулировка:** Дан массив чисел и целевое число. Найдите все уникальные комбинации чисел, которые в сумме дают целевое число.
- **Пример:**
  - Вход: `candidates = [2, 3, 6, 7]`, `target = 7`
  - Выход: `[[2, 2, 3], [7]]`
- **Идея решения:** Используйте backtracking для поиска всех комбинаций.

---

#### **День 34: [Permutations](https://leetcode.com/problems/permutations/) (Medium)**
- **Формулировка:** Дан массив чисел. Найдите все возможные перестановки этих чисел.
- **Пример:**
  - Вход: `nums = [1, 2, 3]`
  - Выход: `[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]`
- **Идея решения:** Используйте backtracking для генерации всех перестановок.

---

#### **День 35: [Subsets](https://leetcode.com/problems/subsets/) (Medium)**
- **Формулировка:** Дан массив чисел. Найдите все возможные подмножества этих чисел.
- **Пример:**
  - Вход: `nums = [1, 2, 3]`
  - Выход: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`
- **Идея решения:** Используйте backtracking или битовые маски для генерации подмножеств.

---

#### **День 36: [Course Schedule](https://leetcode.com/problems/course-schedule/) (Medium)**
- **Формулировка:** Дано количество курсов и список зависимостей (какие курсы нужно пройти перед другими). Определите, можно ли завершить все курсы.
- **Пример:**
  - Вход: `numCourses = 2`, `prerequisites = [[1, 0]]`
  - Выход: `true` (можно пройти курс 0, затем курс 1)
- **Идея решения:** Используйте топологическую сортировку или DFS для обнаружения циклов.

---

#### **День 37: [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/) (Medium)**
- **Формулировка:** Дан двумерный массив высот. Определите, в какие клетки вода может течь как в Тихий, так и в Атлантический океан.
- **Пример:**
  - Вход: 
    ```
    [
      [1, 2, 2, 3, 5],
      [3, 2, 3, 4, 4],
      [2, 4, 5, 3, 1],
      [6, 7, 1, 4, 5],
      [5, 1, 1, 2, 4]
    ]
    ```
  - Выход: `[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]`
- **Идея решения:** Используйте BFS или DFS для обхода от океанов.

---

#### **День 38: [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) (Medium)**
- **Формулировка:** Дан массив чисел. Найдите длину самой длинной возрастающей подпоследовательности.
- **Пример:**
  - Вход: `nums = [10, 9, 2, 5, 3, 7, 101, 18]`
  - Выход: `4` (2, 3, 7, 101)
- **Идея решения:** Используйте динамическое программирование или бинарный поиск.

---

#### **День 39: [Edit Distance](https://leetcode.com/problems/edit-distance/) (Hard)**
- **Формулировка:** Даны две строки. Найдите минимальное количество операций (вставка, удаление, замена), чтобы преобразовать одну строку в другую.
- **Пример:**
  - Вход: `word1 = "horse"`, `word2 = "ros"`
  - Выход: `3` (заменить 'h' на 'r', удалить 'r', удалить 'e')
- **Идея решения:** Используйте динамическое программирование для подсчета операций.

---

#### **День 40: [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) (Hard)**
- **Формулировка:** Даны строка и шаблон. Определите, соответствует ли строка шаблону (с поддержкой `.` и `*`).
- **Пример:**
  - Вход: `s = "aab"`, `p = "c*a*b"`
  - Выход: `true`
- **Идея решения:** Используйте динамическое программирование для сопоставления шаблона.

---

#### **День 41: [Word Ladder](https://leetcode.com/problems/word-ladder/) (Hard)**
- **Формулировка:** Даны два слова и список слов. Найдите длину кратчайшей последовательности преобразований из первого слова во второе, меняя по одной букве за раз.
- **Пример:**
  - Вход: `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot", "dot", "dog", "lot", "log", "cog"]`
  - Выход: `5` ("hit" -> "hot" -> "dot" -> "dog" -> "cog")
- **Идея решения:** Используйте BFS для поиска кратчайшего пути.

---

#### **День 42: [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) (Hard)**
- **Формулировка:** Дан массив чисел и размер окна `k`. Найдите максимальное значение в каждом окне.
- **Пример:**
  - Вход: `nums = [1, 3, -1, -3, 5, 3, 6, 7]`, `k = 3`
  - Выход: `[3, 3, 5, 5, 6, 7]`
- **Идея решения:** Используйте deque (двустороннюю очередь) для эффективного поиска максимума.

---

#### **День 43: [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/) (Easy)**
- **Формулировка:** Даны два отсортированных массива `nums1` и `nums2`. Объедините их в один отсортированный массив.
- **Пример:**
  - Вход: `nums1 = [1, 2, 3, 0, 0, 0]`, `m = 3`, `nums2 = [2, 5, 6]`, `n = 3`
  - Выход: `[1, 2, 2, 3, 5, 6]`
- **Идея решения:** Используйте два указателя, начиная с конца массивов.

---

#### **День 44: [Move Zeroes](https://leetcode.com/problems/move-zeroes/) (Easy)**
- **Формулировка:** Дан массив. Переместите все нули в конец, сохраняя порядок остальных элементов.
- **Пример:**
  - Вход: `nums = [0, 1, 0, 3, 12]`
  - Выход: `[1, 3, 12, 0, 0]`
- **Идея решения:** Используйте два указателя: один для текущего элемента, другой для позиции ненулевого элемента.

---

#### **День 45: [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) (Easy)**
- **Формулировка:** Дана строка, содержащая только символы `(`, `)`, `{`, `}`, `[`, `]`. Определите, является ли строка валидной.
- **Пример:**
  - Вход: `s = "()[]{}"`
  - Выход: `true`
- **Идея решения:** Используйте стек для проверки соответствия скобок.

---

#### **День 46: [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) (Easy)**
- **Формулировка:** Реализуйте очередь, используя два стека.
- **Пример:**
  - Вход: `push(1)`, `push(2)`, `peek()`, `pop()`, `empty()`
  - Выход: `1`, `1`, `false`
- **Идея решения:** Используйте два стека для симуляции очереди.

---

#### **День 47: [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) (Medium)**
- **Формулировка:** Найдите k-й наибольший элемент в массиве.
- **Пример:**
  - Вход: `nums = [3, 2, 1, 5, 6, 4]`, `k = 2`
  - Выход: `5`
- **Идея решения:** Используйте Quickselect или min-heap.

---

#### **День 48: [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) (Medium)**
- **Формулировка:** Дан массив чисел. Найдите k наиболее часто встречающихся элементов.
- **Пример:**
  - Вход: `nums = [1, 1, 1, 2, 2, 3]`, `k = 2`
  - Выход: `[1, 2]`
- **Идея решения:** Используйте хэш-таблицу для подсчета частот и min-heap для выбора k элементов.

---

#### **День 49: [Find Peak Element](https://leetcode.com/problems/find-peak-element/) (Medium)**
- **Формулировка:** Дан массив. Найдите индекс любого пикового элемента (элемент, который больше своих соседей).
- **Пример:**
  - Вход: `nums = [1, 2, 3, 1]`
  - Выход: `2` (элемент 3)
- **Идея решения:** Используйте бинарный поиск для эффективного поиска пика.

---

#### **День 50: [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) (Medium)**
- **Формулировка:** Дан отсортированный массив, который был повернут. Найдите индекс целевого элемента.
- **Пример:**
  - Вход: `nums = [4, 5, 6, 7, 0, 1, 2]`, `target = 0`
  - Выход: `4`
- **Идея решения:** Используйте модифицированный бинарный поиск.

---

#### **День 51: [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) (Hard)**
- **Формулировка:** Даны две строки `s` и `t`. Найдите минимальную подстроку в `s`, которая содержит все символы из `t`.
- **Пример:**
  - Вход: `s = "ADOBECODEBANC"`, `t = "ABC"`
  - Выход: `"BANC"`
- **Идея решения:** Используйте sliding window и хэш-таблицу для подсчета символов.

---

#### **День 52: [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) (Medium)**
- **Формулировка:** Дан массив целых чисел и число `k`. Найдите количество подмассивов, сумма которых равна `k`.
- **Пример:**
  - Вход: `nums = [1, 1, 1]`, `k = 2`
  - Выход: `2` (подмассивы `[1, 1]` и `[1, 1]`)
- **Идея решения:** Используйте хэш-таблицу для хранения префиксных сумм.

---

#### **День 53: [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/) (Medium)**
- **Формулировка:** Дана строка. Найдите количество палиндромных подстрок.
- **Пример:**
  - Вход: `s = "abc"`
  - Выход: `3` ("a", "b", "c")
- **Идея решения:** Используйте расширение вокруг центра для поиска палиндромов.

---

#### **День 54: [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) (Medium)**
- **Формулировка:** Даны две строки. Найдите длину их наибольшей общей подпоследовательности.
- **Пример:**
  - Вход: `text1 = "abcde"`, `text2 = "ace"`
  - Выход: `3` ("ace")
- **Идея решения:** Используйте динамическое программирование.

---

#### **День 55: [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/) (Medium)**
- **Формулировка:** Дан массив целых чисел. Найдите подмассив с максимальным произведением.
- **Пример:**
  - Вход: `nums = [2, 3, -2, 4]`
  - Выход: `6` (подмассив `[2, 3]`)
- **Идея решения:** Используйте динамическое программирование для отслеживания минимального и максимального произведения.

---

#### **День 56: [Coin Change](https://leetcode.com/problems/coin-change/) (Medium)**
- **Формулировка:** Даны монеты разных номиналов и сумма. Найдите минимальное количество монет, необходимых для получения суммы.
- **Пример:**
  - Вход: `coins = [1, 2, 5]`, `amount = 11`
  - Выход: `3` (5 + 5 + 1)
- **Идея решения:** Используйте динамическое программирование.

---

#### **День 57: [Decode Ways](https://leetcode.com/problems/decode-ways/) (Medium)**
- **Формулировка:** Дана строка из цифр. Определите количество способов декодировать её в буквы (A=1, B=2, ..., Z=26).
- **Пример:**
  - Вход: `s = "12"`
  - Выход: `2` ("AB" или "L")
- **Идея решения:** Используйте динамическое программирование.

---

#### **День 58: [Unique Paths](https://leetcode.com/problems/unique-paths/) (Medium)**
- **Формулировка:** Дана сетка m x n. Найдите количество уникальных путей из左上角 в右下角 (движение только вниз или вправо).
- **Пример:**
  - Вход: `m = 3`, `n = 7`
  - Выход: `28`
- **Идея решения:** Используйте динамическое программирование или комбинаторику.

---

#### **День 59: [Jump Game](https://leetcode.com/problems/jump-game/) (Medium)**
- **Формулировка:** Дан массив, где каждый элемент указывает максимальную длину прыжка. Определите, можно ли добраться до конца массива.
- **Пример:**
  - Вход: `nums = [2, 3, 1, 1, 4]`
  - Выход: `true`
- **Идея решения:** Используйте жадный алгоритм.

---

#### **День 60: [Task Scheduler](https://leetcode.com/problems/task-scheduler/) (Medium)**
- **Формулировка:** Даны задачи и время охлаждения. Найдите минимальное время для выполнения всех задач.
- **Пример:**
  - Вход: `tasks = ["A", "A", "A", "B", "B", "B"]`, `n = 2`
  - Выход: `8` (A -> B -> idle -> A -> B -> idle -> A -> B)
- **Идея решения:** Используйте жадный алгоритм и приоритетную очередь.
